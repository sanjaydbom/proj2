# CS 118 Project 2

**Due Date:** Refer to Canvas/Gradescope

## Overview

In this project, you will implement a secure transport layer on top of a reliable network connection. Your security layer will ensure:

1.  **Authenticity**: The client validates the server's identity using a Chain of Trust (Certificates).
2.  **Privacy**: All data is encrypted (AES-256) so third parties cannot read it.
3.  **Integrity**: Messages are protected against tampering (HMAC-SHA256).

You will implement the handshake state machine and data protection logic in `src/security.c`. All cryptographic primitives (AES, SHA, Key Generation) and low-level networking/serialization are provided in `src/libsecurity.c` and other helper files.

## Protocol Specification

The security layer communicates using **Type-Length-Value (TLV)** encoded messages. You do not need to manage the byte-level encoding manually; helper functions in `consts.h` (like `create_tlv`, `add_tlv`, `serialize_tlv`) handle the memory and formatting for you.
Put simply, TLV encoding allows you to provide the type and length of your content so that the program parsing the content knows what it is and doesn't overflow a buffer. 
Within the content, you can provide more TLV-formatted content. For example, the Client Hello has a specific type, calculated length, and then Version, Nonce, and Public Key TLVs as its "value". 

### Handshake Protocol (1-RTT)

The handshake establishes the shared session keys.

#### Step 1: Client Hello (State: `CLIENT_CLIENT_HELLO_SEND`)
The client initiates the connection by sending a **Client Hello** message.

* **Structure**: A `CLIENT_HELLO` TLV container containing:
    1.  **Version** : Must be set to `PROTOCOL_VERSION` (`0x01`).
    2.  **Nonce** : 32 random bytes generated by the client.
    3.  **Public Key** : The client's ephemeral ECDH public key.

#### Step 2: Server Hello (State: `SERVER_SERVER_HELLO_SEND`)
The server responds with a **Server Hello**.

* **Structure**: A `SERVER_HELLO` TLV container containing:
    1.  **Nonce** : 32 random bytes generated by the server.
    2.  **Certificate** : The server's full certificate (provided in `server_cert.bin`).
    3.  **Public Key** : The server's ephemeral ECDH public key.
    4.  **Signature** : A signature over the **Serialized** fields of the handshake so far:
        * `Serialized(Client Hello TLV)` + `Serialized(Server Nonce TLV)` + `Serialized(Server Ephemeral Public Key TLV)`.

#### Step 3: Verification & Key Derivation
Before the handshake is considered complete, the Client must verify the Server's identity:

1.  **Verify Certificate**:
    * Is the certificate signature valid? (Verified using the CA's public key).
    * Is the certificate within its valid lifetime?
    * Does the Common Name (DNS Name) in the cert match the hostname the client connected to?
2.  **Verify Handshake Signature**:
    * Is the signature in the Server Hello valid? (Verified using the Server's Public Key found inside the Certificate).

**Session Keys**:
If verification passes, both sides derive the session keys using their ephemeral keys:
* **Secret**: ECDH(My Private Key, Peer Public Key).
* **Salt**: `Client_Nonce` (32 bytes) + `Server_Nonce` (32 bytes).
* **Keys**: Derived via HKDF-SHA256:
    * `enc_key` (Info: "enc")
    * `mac_key` (Info: "mac")


### Data Transmission (State: `DATA_STATE`)

Once keys are derived, all subsequent traffic is encrypted.

* **Structure**: A `DATA` TLV container containing:
    1.  **IV** : 16 random bytes.
    2.  **MAC** : 32 bytes.
    3.  **Ciphertext** : The encrypted payload.

**Sending Data**:
1.  Encrypt the plaintext -> Get `IV` and `Ciphertext`.
2.  Calculate HMAC-SHA256 over: `Serialized(IV TLV)` + `Serialized(Ciphertext TLV)`.
3.  Package into a `DATA` TLV and send.

**Receiving Data**:
1.  Extract `IV`, `MAC`, and `Ciphertext`.
2.  Verify integrity: Re-calculate HMAC over the received `IV` and `Ciphertext` TLVs. If it doesn't match the received `MAC`, the message is forged.
3.  Decrypt the ciphertext.

## Implementation Details

### Files
* **`src/security.c`**: **(Edit This)** This is the only file you need to modify. It contains the state machine for `input_sec` (sending) and `output_sec` (receiving).
* **`src/libsecurity.h`**: **(Do Not Edit)** Provides the cryptographic API you must use (e.g., `generate_private_key`, `sign`, `encrypt_data`).
* **`src/consts.h`**: **(Do Not Edit)** Defines TLV types, constants, and helper functions for creating/serializing TLVs.

### Exit Codes
Your code must call `exit(code)` immediately upon detecting these errors. We recommend using these exit codes to help you debug:

| Code | Reason |
| :--- | :--- |
| `1` | **Bad Certificate**: Invalid CA signature or Certificate Expired. |
| `2` | **Bad Identity**: Hostname mismatch (DNS name in cert != target hostname). |
| `3` | **Bad Handshake Signature**: The signature in Server Hello is invalid. |
| `5` | **Bad MAC**: Integrity check failed on a Data message. |
| `6` | **Malformed Message**: Missing required TLVs or wrong protocol version. |

### Provided API (`libsecurity.h`)

* `load_peer_public_key(buf, size)`: Load a public key received from the network.
* `generate_nonce(buf, size)`: Fill a buffer with random bytes.
* `derive_keys(salt, size)`: Run HKDF to populate the global `enc_key` and `mac_key`.
* `encrypt_data(...)` / `decrypt_cipher(...)`: Handle AES-256-CBC.
* `sign(...)` / `verify(...)`: Handle ECDSA signatures.

For more details, please read [the implementation guide](Implementation_Guide.md).

## Running & Testing

We provide a `helper` script to compile and test your code locally, using the same autograder that Gradescope uses.

### Quick Start
1.  **Run All Tests**:
    ```bash
    ./helper run
    ```
2.  **Interactive Debugging**:
    To manually run your client/server inside the test container:
    ```bash
    ./helper interactive
    ```

For detailed instructions on testing and debugging, please read [the testing guide](Testing_Guide.md).

## Submission

Use `./helper zip` to create a `project.zip` file containing your submission.

The autograder will run the same tests as `./helper run`.
